@*@using Wiresheet.Component.Wiresheet.Node
@implements IDisposable
<div class="Wiresheet-queue-container">
    @if (Node?.QueueSize >= 10)
    {
        <div class="Wiresheet-progress-bar-container green-indicator">
            <div class="Wiresheet-progress-bar-indicator" style="width: @GetProgress()%;"></div>
        </div>
    }
    else
    {
        for (var i = 0; i < Node?.ItemsInQueue; i++)
        {
            <div class="Wiresheet-progress-bar-container square  green-indicator">
                <div class="Wiresheet-progress-bar-indicator" style="width: 100%;"></div>
            </div>
        }

        for (var i = 0; i < Node?.QueueSize - Node?.ItemsInQueue; i++)
        {
            <div class="Wiresheet-progress-bar-container square green-indicator">
                <div class="Wiresheet-progress-bar-indicator" style="width: 0;"></div>
            </div>
        }
    }
</div>

<style>

    .queue-container{
        padding-top: 4px;
        display: flex;
        width: 100%;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 4px 4px;
    }

</style>

@code {

    [Parameter] public WiresheetNode Node { get; set; } = null!;


    private double GetProgress()
    {
        return Convert.ToInt32(Node.ItemsInQueue / (double)Node.QueueSize * 100);
    }

    private DateTime _lastUpdate = DateTime.MinValue;

    private void Update()
    {
        if ((DateTime.Now - _lastUpdate > GraphSettings.UpdateInterval) & (Node?.Dragging != true))
        {
            _lastUpdate = DateTime.Now;
            InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnInitialized()
    {
        Node.OnQueueBarUpdateRequest += Update;
    }


    public void Dispose()
    {
        Node.OnQueueBarUpdateRequest -= Update;
    }

}*@